 
 本篇文章简要介绍程序的机器级表示，也就是在程序如何在汇编层面跑起来，如何操作寄存器和内存，这里用一个简单demo来举例说明。

 ### 预备知识

 #### 1.堆栈

    常用数据结构，先进后出。计算机在执行函数时用的函数栈，要明白push和pop的含义。

 #### 2.寄存器
  
   ![Image text](https://github.com/ipk2015/JavaResource/raw/master/blog/img/寄存器.png)

   CPU不能直接操作内存里的数据，需要取出来放到寄存器。
   上面的寄存器结构力有两个地方很重要：EBP和ESP。

      EBP:描述了一个栈帧，永远指向一个栈帧的开始处。
      ESP:永远指向栈顶。
  
 #### 3.汇编
     
    指令                      注释  
    MOVL $0x3051 ,%EAX       把0x3051这个值放到 EAX寄存器， 4个字节
    MOVL %EAX, -12(%EBP)     把寄存器EAX的值，存放到EBP指向的地址减去12个字节的地方
    LEAL -12(%EBP)  %EAX     把 %EBP减去12得到的地址，放到EAX寄存器当中
    PUSHL %EBP               把寄存器EBP的值压栈
    POPL %EBP                把栈顶的值弹出， 存放到EBP寄存器中
    SUBL %4 %ESP             把ESP寄存器的值减去4

 #### 4.指针
    这里指针即变量的内存地址，如在C语言里*变量。
    
 ### 程序演示

 #### 高级语言：C语言
```
    int demo(){
      int x = 10;
      int y = 20;
      int sum = add(&x,  &y);
      printf(“the sum is %d\n”,sum);
      return sum;
    }
   int add(int *xp, int *yp){
      int x = *xp;
      int y = *yp;
      return x+y;
    }
```

 #### 汇编
```
demo:
1    pushl    %ebp
2    movl     %esp %ebp
3    subl    %24 esp
4    movl   $10     -4(%ebp)
5    movl   $20     -8(%ebp)
6    leal    -8(%ebp)     %eax
7    movl  %eax    4(%esp)
8    leal  -4(%ebp)  %eax
9    movl    %eax      esp
call add
打印结果(略)

add:
1    pushl    %ebp
2    movl     %esp %ebp
3    pushl   %ebx
4    movl   8(%ebp)   %edx
5    movl   12(%ebp)    %ecx
6    movl    (%edx)     %ebx
7    movl    (%ecx)    %eax
8    add      %ebx      %eax
9   popl %ebx
10  popl %ebp
11  ret

```
    
